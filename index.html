<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>3D ë³‘ë§› ê²½ë§ˆ (ë§ ë””ìì¸ ê°œì„ )</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Malgun Gothic', sans-serif; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        #setup-box { 
            pointer-events: auto; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.85); padding: 40px; border-radius: 20px; text-align: center; border: 2px solid #5d5dff;
            color: white; box-shadow: 0 0 40px rgba(93, 93, 255, 0.4); z-index: 10;
        }
        textarea { width: 300px; height: 120px; background: #222; color: #fff; border: 1px solid #555; padding: 10px; font-size: 16px; }
        button { 
            background: #5d5dff; color: white; border: none; padding: 15px 40px; font-size: 20px; 
            margin-top: 20px; cursor: pointer; font-weight: bold; border-radius: 50px; transition: 0.3s;
        }
        button:hover { background: #8e8eff; transform: scale(1.05); }
        
        #broadcast {
            position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%);
            width: 80%; text-align: center; pointer-events: none;
        }
        #broadcast-text {
            background: rgba(0,0,0,0.7); color: #00ffcc; padding: 15px 30px;
            font-size: 24px; border-radius: 30px; display: inline-block;
            text-shadow: 0 0 10px #00ffcc; border: 1px solid #00ffcc; transition: transform 0.1s;
        }

        #rank-board {
            display: none; pointer-events: auto; position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%); background: rgba(0,0,0,0.95); padding: 40px;
            border: 4px solid gold; color: white; border-radius: 20px; text-align: center; min-width: 300px; z-index: 20;
        }
        
        .top-info { position: absolute; top: 20px; width: 100%; display: flex; justify-content: space-between; padding: 0 40px; box-sizing: border-box; }
        .info-badge { background: rgba(0,0,0,0.5); color: #fff; padding: 10px 20px; border-radius: 10px; font-weight: bold; border: 1px solid #555; }
        
        li { font-size: 24px; list-style: none; margin: 15px 0; border-bottom: 1px solid #444; padding-bottom: 5px; }
        .winner { color: gold; font-size: 30px; font-weight: bold; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }
        
        #flash-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: white;
            opacity: 0; pointer-events: none; transition: opacity 0.1s; z-index: 5;
        }

        #countdown {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 200px; font-weight: bold; color: #fff; text-shadow: 0 0 50px #ff0, 0 0 100px #f00;
            z-index: 15; animation: countPulse 0.5s ease-out;
        }
        @keyframes countPulse {
            0% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
    </style>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>
</head>
<body>

    <div id="flash-overlay"></div>
    <div id="countdown"></div>
    <div id="ui-layer">
        <div class="top-info">
            <div class="info-badge" id="distLabel">ë‚¨ì€ ê±°ë¦¬: 3500m</div>
            <div class="info-badge" id="gapLabel">2ë“±ê³¼ì˜ ê²©ì°¨: 0m</div>
        </div>

        <div id="setup-box">
            <h1 style="margin-top:0; color:#5d5dff;">ğŸ ë…ì£¼ ê¸ˆì§€ ë ˆì´ìŠ¤</h1>
            <p>ì°¸ê°€ì ì…ë ¥ (ì¤„ë°”ê¿ˆ)</p>
            <textarea id="names">í˜ê°€ìˆ˜ìŠ¤
ìœ ë‹ˆì½˜
ë‹¤í¬í˜¸ìŠ¤
ì²œë§ˆ
ê²½ì£¼ë§ˆ
ë¡œë´‡ë§</textarea><br>
            <button id="startBtn">âš¡ RACE START âš¡</button>
        </div>

        <div id="broadcast">
            <div id="broadcast-text">ì¤‘ê³„ì„: ë…ì£¼í•˜ë©´ ë²¼ë½ ë§ìŠµë‹ˆë‹¤!</div>
        </div>

        <div id="rank-board">
            <h1 style="color:gold">ğŸ† ê²½ê¸° ê²°ê³¼ ğŸ†</h1>
            <ul id="rank-list" style="padding:0"></ul>
            <button onclick="location.reload()">ë‹¤ì‹œ í•˜ê¸°</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';

        let scene, camera, renderer, dirLight;
        let horses = [];
        let isRacing = false;
        
        const finishLineZ = -3500; 
        const PENALTY_THRESHOLD = 400; 

        let frameCount = 0;
        let finishedCount = 0;
        let cameraMode = 0; 

        const colors = [0xff6b6b, 0x4caf50, 0x5d5dff, 0xffa040, 0x8e5b4b, 0xcccccc, 0x00bcd4, 0x9c27b0];
        
        // --- ì‚¬ìš´ë“œ ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playTone(freq, type, dur, vol=0.1) {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.value = freq;
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            gain.gain.value = vol;
            osc.start();
            gain.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + dur);
            osc.stop(audioCtx.currentTime + dur);
        }
        function playThunder() {
            playTone(100, 'sawtooth', 0.5, 0.5);
            playTone(50, 'square', 0.8, 0.5);
        }

        // --- í­ì£½ ì†Œë¦¬ ---
        function playFirework() {
            if(audioCtx.state === 'suspended') audioCtx.resume();

            // ë°œì‚¬ ì†Œë¦¬ (íœ˜ì´ì´ì‰)
            const launchOsc = audioCtx.createOscillator();
            const launchGain = audioCtx.createGain();
            launchOsc.type = 'sawtooth';
            launchOsc.frequency.setValueAtTime(200, audioCtx.currentTime);
            launchOsc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.3);
            launchOsc.connect(launchGain);
            launchGain.connect(audioCtx.destination);
            launchGain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            launchGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
            launchOsc.start();
            launchOsc.stop(audioCtx.currentTime + 0.3);

            // í­ë°œ ì†Œë¦¬ (ë¹µ!)
            setTimeout(() => {
                // ë…¸ì´ì¦ˆ ìƒì„±
                const bufferSize = audioCtx.sampleRate * 0.3;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.1));
                }
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;

                const noiseGain = audioCtx.createGain();
                noiseGain.gain.setValueAtTime(0.5, audioCtx.currentTime);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);

                noise.connect(noiseGain);
                noiseGain.connect(audioCtx.destination);
                noise.start();

                // ë°˜ì§ì´ ì†Œë¦¬ (ì°Œì§€ì§)
                for (let j = 0; j < 5; j++) {
                    setTimeout(() => {
                        playTone(1000 + Math.random() * 2000, 'sine', 0.1, 0.1);
                    }, j * 50);
                }
            }, 300);
        }

        // --- í­ì£½ íŒŒí‹°í´ ---
        let fireworkParticles = [];

        function createFirework(position) {
            const particleCount = 100;
            const colors = [0xff0000, 0xffff00, 0x00ff00, 0x00ffff, 0xff00ff, 0xffa500, 0xffffff];

            for (let i = 0; i < particleCount; i++) {
                const geo = new THREE.SphereGeometry(1, 4, 4);
                const mat = new THREE.MeshBasicMaterial({
                    color: colors[Math.floor(Math.random() * colors.length)],
                    transparent: true,
                    opacity: 1
                });
                const particle = new THREE.Mesh(geo, mat);

                particle.position.copy(position);
                particle.position.y += 50;

                // ëœë¤ ë°©í–¥ìœ¼ë¡œ í¼ì§€ëŠ” ì†ë„
                const angle = Math.random() * Math.PI * 2;
                const angle2 = Math.random() * Math.PI;
                const speed = 2 + Math.random() * 3;
                particle.userData.velocity = new THREE.Vector3(
                    Math.sin(angle2) * Math.cos(angle) * speed,
                    Math.cos(angle2) * speed + 2,
                    Math.sin(angle2) * Math.sin(angle) * speed
                );
                particle.userData.life = 1.0;
                particle.userData.decay = 0.01 + Math.random() * 0.01;

                scene.add(particle);
                fireworkParticles.push(particle);
            }

            playFirework();
        }

        function updateFireworks() {
            for (let i = fireworkParticles.length - 1; i >= 0; i--) {
                const p = fireworkParticles[i];

                // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                p.position.add(p.userData.velocity);
                p.userData.velocity.y -= 0.08; // ì¤‘ë ¥
                p.userData.velocity.multiplyScalar(0.98); // ê³µê¸°ì €í•­

                // ìˆ˜ëª… ê°ì†Œ
                p.userData.life -= p.userData.decay;
                p.material.opacity = p.userData.life;

                // ìˆ˜ëª… ë‹¤í•˜ë©´ ì œê±°
                if (p.userData.life <= 0) {
                    scene.remove(p);
                    p.geometry.dispose();
                    p.material.dispose();
                    fireworkParticles.splice(i, 1);
                }
            }
        }

        // ì—°ì† í­ì£½ (1ë“± ì¶•í•˜)
        function celebrateWinner(position) {
            // ì²« í­ì£½
            createFirework(position);

            // ì¶”ê°€ í­ì£½ë“¤ (ì‹œê°„ì°¨)
            setTimeout(() => createFirework(new THREE.Vector3(position.x - 50, 0, position.z)), 300);
            setTimeout(() => createFirework(new THREE.Vector3(position.x + 50, 0, position.z)), 500);
            setTimeout(() => createFirework(new THREE.Vector3(position.x, 0, position.z - 30)), 700);
            setTimeout(() => createFirework(new THREE.Vector3(position.x + 30, 0, position.z + 30)), 900);
        }

        // --- êµ¬ë¦„ ë°°ì—´ ---
        let clouds = [];

        // --- í•˜ëŠ˜ ë°°ê²½ ìƒì„± ---
        function createSky() {
            // ê·¸ë¼ë°ì´ì…˜ í•˜ëŠ˜ (ìœ„: ì§„í•œ íŒŒë‘, ì•„ë˜: í•˜ëŠ˜ìƒ‰)
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createLinearGradient(0, 0, 0, 512);
            gradient.addColorStop(0, '#1e3c72');    // ì§„í•œ íŒŒë‘ (ìœ„)
            gradient.addColorStop(0.3, '#2a5298');  // ì¤‘ê°„ íŒŒë‘
            gradient.addColorStop(0.6, '#87ceeb');  // í•˜ëŠ˜ìƒ‰
            gradient.addColorStop(1, '#b0e0e6');    // ì—°í•œ í•˜ëŠ˜ìƒ‰ (ì•„ë˜/ìˆ˜í‰ì„ )
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);

            const skyTexture = new THREE.CanvasTexture(canvas);
            scene.background = skyTexture;
        }

        // --- êµ¬ë¦„ ìƒì„± ---
        function createClouds() {
            const cloudGroup = new THREE.Group();

            for (let i = 0; i < 30; i++) {
                const cloud = new THREE.Group();

                // êµ¬ë¦„ì€ ì—¬ëŸ¬ ê°œì˜ êµ¬ì²´ë¡œ êµ¬ì„±
                const puffCount = 3 + Math.floor(Math.random() * 4);
                for (let j = 0; j < puffCount; j++) {
                    const puffGeo = new THREE.SphereGeometry(
                        20 + Math.random() * 30, 8, 6
                    );
                    const puffMat = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.85
                    });
                    const puff = new THREE.Mesh(puffGeo, puffMat);
                    puff.position.set(
                        j * 25 - puffCount * 12,
                        Math.random() * 10 - 5,
                        Math.random() * 15 - 7
                    );
                    puff.scale.y = 0.6; // êµ¬ë¦„ì„ ë‚©ì‘í•˜ê²Œ
                    cloud.add(puff);
                }

                // êµ¬ë¦„ ìœ„ì¹˜ (ë„“ê²Œ ë¶„í¬)
                cloud.position.set(
                    Math.random() * 2000 - 1000,
                    150 + Math.random() * 200,
                    Math.random() * -4500
                );
                cloud.userData.speed = 0.1 + Math.random() * 0.2;

                cloudGroup.add(cloud);
                clouds.push(cloud);
            }

            scene.add(cloudGroup);
        }

        // --- êµ¬ë¦„ ì• ë‹ˆë©”ì´ì…˜ ---
        function updateClouds() {
            clouds.forEach(cloud => {
                cloud.position.x += cloud.userData.speed;
                if (cloud.position.x > 1200) {
                    cloud.position.x = -1200;
                }
            });
        }

        // --- íŠ¸ë™ ì„¤ì • ---
        const LANE_WIDTH = 30; // ë ˆì¸ í•˜ë‚˜ì˜ ë„ˆë¹„
        const MIN_LANES = 8;
        const MAX_LANES = 20;
        let currentTrackWidth = LANE_WIDTH * MIN_LANES;
        let trackObjects = []; // ë™ì  íŠ¸ë™ ì˜¤ë¸Œì íŠ¸ë“¤

        // --- ê¸°ë³¸ ë°”ë‹¥ ìƒì„± ---
        function createGround() {
            // ì”ë”” (ì „ì²´ ë°”ë‹¥)
            const grassGeo = new THREE.PlaneGeometry(2000, 10000);
            const grassMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            const grass = new THREE.Mesh(grassGeo, grassMat);
            grass.rotation.x = -Math.PI / 2;
            grass.position.set(0, -0.5, -2000);
            grass.receiveShadow = true;
            scene.add(grass);
        }

        // --- ë™ì  íŠ¸ë™ ìƒì„± ---
        function createTrack(laneCount) {
            // ê¸°ì¡´ íŠ¸ë™ ì˜¤ë¸Œì íŠ¸ ì œê±°
            trackObjects.forEach(obj => {
                scene.remove(obj);
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
            });
            trackObjects = [];

            // ë ˆì¸ ìˆ˜ ê³„ì‚° (ìµœì†Œ 8, ìµœëŒ€ 20)
            const lanes = Math.max(MIN_LANES, Math.min(MAX_LANES, laneCount));
            currentTrackWidth = LANE_WIDTH * lanes;

            // í™ íŠ¸ë™ (ê²½ì£¼ë¡œ)
            const trackGeo = new THREE.PlaneGeometry(currentTrackWidth, 10000);
            const trackMat = new THREE.MeshStandardMaterial({ color: 0xc2956e });
            const track = new THREE.Mesh(trackGeo, trackMat);
            track.rotation.x = -Math.PI / 2;
            track.position.set(0, 0, -2000);
            track.receiveShadow = true;
            scene.add(track);
            trackObjects.push(track);

            // íŠ¸ë™ ë¼ì¸ (ë ˆì¸ êµ¬ë¶„ì„ )
            const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const lineGeo = new THREE.PlaneGeometry(2, 10000);

            // ë ˆì¸ êµ¬ë¶„ì„  (ë ˆì¸ ìˆ˜ - 1 ê°œ)
            for (let i = 1; i < lanes; i++) {
                const line = new THREE.Mesh(lineGeo.clone(), lineMat.clone());
                line.rotation.x = -Math.PI / 2;
                line.position.set(-currentTrackWidth/2 + i * LANE_WIDTH, 0.5, -2000);
                scene.add(line);
                trackObjects.push(line);
            }

            // íŠ¸ë™ ê²½ê³„ì„  (ì–‘ìª½ êµµì€ ì„ )
            const borderGeo = new THREE.PlaneGeometry(5, 10000);
            const borderMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });

            const leftBorder = new THREE.Mesh(borderGeo.clone(), borderMat.clone());
            leftBorder.rotation.x = -Math.PI / 2;
            leftBorder.position.set(-currentTrackWidth/2, 0.5, -2000);
            scene.add(leftBorder);
            trackObjects.push(leftBorder);

            const rightBorder = new THREE.Mesh(borderGeo.clone(), borderMat.clone());
            rightBorder.rotation.x = -Math.PI / 2;
            rightBorder.position.set(currentTrackWidth/2, 0.5, -2000);
            scene.add(rightBorder);
            trackObjects.push(rightBorder);

            // íœìŠ¤ (ì–‘ìª½)
            const fencePostGeo = new THREE.BoxGeometry(3, 20, 3);
            const fencePostMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const fenceRailGeo = new THREE.BoxGeometry(2, 3, 100);
            const fenceRailMat = new THREE.MeshStandardMaterial({ color: 0xffffff });

            for (let z = 0; z > -4500; z -= 100) {
                const postL = new THREE.Mesh(fencePostGeo.clone(), fencePostMat.clone());
                postL.position.set(-currentTrackWidth/2 - 30, 10, z);
                postL.castShadow = true;
                scene.add(postL);
                trackObjects.push(postL);

                const postR = new THREE.Mesh(fencePostGeo.clone(), fencePostMat.clone());
                postR.position.set(currentTrackWidth/2 + 30, 10, z);
                postR.castShadow = true;
                scene.add(postR);
                trackObjects.push(postR);

                if (z > -4400) {
                    const railL = new THREE.Mesh(fenceRailGeo.clone(), fenceRailMat.clone());
                    railL.position.set(-currentTrackWidth/2 - 30, 15, z - 50);
                    scene.add(railL);
                    trackObjects.push(railL);

                    const railR = new THREE.Mesh(fenceRailGeo.clone(), fenceRailMat.clone());
                    railR.position.set(currentTrackWidth/2 + 30, 15, z - 50);
                    scene.add(railR);
                    trackObjects.push(railR);
                }
            }

            // ê±°ë¦¬ í‘œì‹œíŒ (ë§¤ 500m)
            for (let dist = 500; dist <= 3500; dist += 500) {
                const markerCanvas = document.createElement('canvas');
                markerCanvas.width = 128;
                markerCanvas.height = 64;
                const mctx = markerCanvas.getContext('2d');
                mctx.fillStyle = '#ffffff';
                mctx.fillRect(0, 0, 128, 64);
                mctx.fillStyle = '#000000';
                mctx.font = 'bold 40px Arial';
                mctx.textAlign = 'center';
                mctx.fillText(`${dist}m`, 64, 48);

                const markerTexture = new THREE.CanvasTexture(markerCanvas);
                const markerMat = new THREE.MeshBasicMaterial({ map: markerTexture });
                const markerGeo = new THREE.PlaneGeometry(20, 10);

                const markerL = new THREE.Mesh(markerGeo.clone(), markerMat.clone());
                markerL.position.set(-currentTrackWidth/2 - 50, 30, -dist);
                markerL.rotation.y = Math.PI / 4;
                scene.add(markerL);
                trackObjects.push(markerL);

                const markerR = new THREE.Mesh(markerGeo.clone(), markerMat.clone());
                markerR.position.set(currentTrackWidth/2 + 50, 30, -dist);
                markerR.rotation.y = -Math.PI / 4;
                scene.add(markerR);
                trackObjects.push(markerR);
            }
        }

        // --- ê²°ìŠ¹ì„  ì˜¤ë¸Œì íŠ¸ ---
        let finishLineObjects = [];

        // --- ê²°ìŠ¹ì„  ìƒì„± ---
        function createFinishLine() {
            // ê¸°ì¡´ ê²°ìŠ¹ì„  ì œê±°
            finishLineObjects.forEach(obj => {
                scene.remove(obj);
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
            });
            finishLineObjects = [];

            // ê²°ìŠ¹ì„  ë°”ë‹¥
            const finishLineGeo = new THREE.BoxGeometry(currentTrackWidth + 20, 10, 15);
            const finishLineMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const finishLine = new THREE.Mesh(finishLineGeo, finishLineMat);
            finishLine.position.set(0, 5, finishLineZ);
            scene.add(finishLine);
            finishLineObjects.push(finishLine);

            // ê²°ìŠ¹ ê²Œì´íŠ¸
            const gatePostGeo = new THREE.BoxGeometry(10, 80, 10);
            const gatePostMat = new THREE.MeshStandardMaterial({ color: 0xffffff });

            const gateL = new THREE.Mesh(gatePostGeo.clone(), gatePostMat.clone());
            gateL.position.set(-currentTrackWidth/2 - 15, 40, finishLineZ);
            gateL.castShadow = true;
            scene.add(gateL);
            finishLineObjects.push(gateL);

            const gateR = new THREE.Mesh(gatePostGeo.clone(), gatePostMat.clone());
            gateR.position.set(currentTrackWidth/2 + 15, 40, finishLineZ);
            gateR.castShadow = true;
            scene.add(gateR);
            finishLineObjects.push(gateR);

            const gateTopGeo = new THREE.BoxGeometry(currentTrackWidth + 50, 15, 15);
            const gateTop = new THREE.Mesh(gateTopGeo, gatePostMat.clone());
            gateTop.position.set(0, 85, finishLineZ);
            scene.add(gateTop);
            finishLineObjects.push(gateTop);

            // FINISH í…ìŠ¤íŠ¸
            const finishCanvas = document.createElement('canvas');
            finishCanvas.width = 512;
            finishCanvas.height = 128;
            const fctx = finishCanvas.getContext('2d');
            fctx.fillStyle = '#ff0000';
            fctx.fillRect(0, 0, 512, 128);
            fctx.fillStyle = '#ffffff';
            fctx.font = 'bold 80px Arial';
            fctx.textAlign = 'center';
            fctx.fillText('FINISH', 256, 95);

            const finishTexture = new THREE.CanvasTexture(finishCanvas);
            const finishSignMat = new THREE.MeshBasicMaterial({ map: finishTexture });
            const finishSign = new THREE.Mesh(new THREE.PlaneGeometry(100, 25), finishSignMat);
            finishSign.position.set(0, 110, finishLineZ + 1);
            scene.add(finishSign);
            finishLineObjects.push(finishSign);
        }

        // --- ì´ˆê¸°í™” ---
        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87ceeb, 800, 4000); // í•˜ëŠ˜ìƒ‰ ì•ˆê°œ

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 5000);
            camera.position.set(0, 50, 100);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // í•˜ëŠ˜ ìƒì„±
            createSky();

            // êµ¬ë¦„ ìƒì„±
            createClouds();

            // ê¸°ë³¸ ë°”ë‹¥ ìƒì„±
            createGround();

            // ê¸°ë³¸ 8ë ˆì¸ íŠ¸ë™ ìƒì„±
            createTrack(MIN_LANES);

            // ê²°ìŠ¹ì„  ìƒì„±
            createFinishLine();

            // ì¡°ëª…
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            dirLight = new THREE.DirectionalLight(0xfffacd, 1.2); // ë”°ëœ»í•œ í–‡ë¹›
            dirLight.position.set(100, 200, 100);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.left = -300; dirLight.shadow.camera.right = 300;
            dirLight.shadow.camera.top = 300; dirLight.shadow.camera.bottom = -300;
            scene.add(dirLight);

            // íƒœì–‘ (ì‹œê°ì )
            const sunGeo = new THREE.SphereGeometry(50, 16, 16);
            const sunMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const sun = new THREE.Mesh(sunGeo, sunMat);
            sun.position.set(500, 400, -2000);
            scene.add(sun);

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        // --- ë§ í´ë˜ìŠ¤ (ë””ìì¸ ê°œì„ ) ---
        class Horse3D {
            constructor(name, index, total) {
                this.name = name;
                this.mesh = new THREE.Group();
                this.originalColor = colors[index % colors.length];

                this.bodyMat = new THREE.MeshStandardMaterial({ color: this.originalColor });
                this.headMat = new THREE.MeshStandardMaterial({ color: this.originalColor });
                const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
                const blackMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
                const hoofMat = new THREE.MeshStandardMaterial({ color: 0x333333 });

                // === ëª¸í†µ (íƒ€ì›í˜•) ===
                const bodyGeo = new THREE.CapsuleGeometry(6, 18, 8, 16);
                this.body = new THREE.Mesh(bodyGeo, this.bodyMat);
                this.body.rotation.x = Math.PI / 2; // ì•ë’¤ë¡œ ëˆ•í˜ (ë‹¬ë¦¬ëŠ” ë°©í–¥)
                this.body.position.set(0, 15, 0);
                this.body.castShadow = true;
                this.mesh.add(this.body);

                // === ëª©+ë¨¸ë¦¬ ê·¸ë£¹ ===
                this.headGroup = new THREE.Group();
                this.headGroup.position.set(0, 18, -12);

                // ëª© (ê¸°ìš¸ì–´ì§„ ì›ê¸°ë‘¥)
                const neckGeo = new THREE.CylinderGeometry(3, 4, 14, 8);
                this.neck = new THREE.Mesh(neckGeo, this.bodyMat);
                this.neck.position.set(0, 5, -3);
                this.neck.rotation.x = -0.6; // ì•ìœ¼ë¡œ ê¸°ìš¸ì„
                this.neck.castShadow = true;
                this.headGroup.add(this.neck);

                // ë¨¸ë¦¬ (ê¸¸ì­‰í•œ ë°•ìŠ¤)
                const headGeo = new THREE.BoxGeometry(5, 6, 14);
                this.head = new THREE.Mesh(headGeo, this.headMat);
                this.head.position.set(0, 12, -10);
                this.head.rotation.x = -0.3;
                this.head.castShadow = true;
                this.headGroup.add(this.head);

                // ì½”/ì£¼ë‘¥ì´ (ì•ìœ¼ë¡œ íŠ€ì–´ë‚˜ì˜¨ ë¶€ë¶„)
                const snoutGeo = new THREE.BoxGeometry(4, 4, 5);
                const snout = new THREE.Mesh(snoutGeo, this.headMat);
                snout.position.set(0, -1, -8);
                this.head.add(snout);

                // ì½§êµ¬ë©
                const nostrilGeo = new THREE.SphereGeometry(0.5, 6, 6);
                const nostrilL = new THREE.Mesh(nostrilGeo, blackMat);
                nostrilL.position.set(-1, -1, -2.5);
                snout.add(nostrilL);
                const nostrilR = new THREE.Mesh(nostrilGeo, blackMat);
                nostrilR.position.set(1, -1, -2.5);
                snout.add(nostrilR);

                // ëˆˆ (ì–‘ìª½)
                const eyeGeo = new THREE.SphereGeometry(1, 8, 8);
                const eyeL = new THREE.Mesh(eyeGeo, whiteMat);
                eyeL.position.set(-2.5, 1, -2);
                this.head.add(eyeL);
                const eyeR = new THREE.Mesh(eyeGeo, whiteMat);
                eyeR.position.set(2.5, 1, -2);
                this.head.add(eyeR);

                // ëˆˆë™ì
                const pupilGeo = new THREE.SphereGeometry(0.5, 6, 6);
                const pupilL = new THREE.Mesh(pupilGeo, blackMat);
                pupilL.position.set(-0.3, 0, -0.7);
                eyeL.add(pupilL);
                const pupilR = new THREE.Mesh(pupilGeo, blackMat);
                pupilR.position.set(0.3, 0, -0.7);
                eyeR.add(pupilR);

                // ê·€ (ì‚¼ê°ë¿”)
                const earGeo = new THREE.ConeGeometry(1.5, 5, 4);
                this.earL = new THREE.Mesh(earGeo, this.bodyMat);
                this.earL.position.set(-2, 5, 0);
                this.earL.rotation.z = -0.3;
                this.earL.rotation.x = -0.2;
                this.head.add(this.earL);

                this.earR = new THREE.Mesh(earGeo, this.bodyMat);
                this.earR.position.set(2, 5, 0);
                this.earR.rotation.z = 0.3;
                this.earR.rotation.x = -0.2;
                this.head.add(this.earR);

                // ê°ˆê¸° (ëª© ìœ„ì— ì—¬ëŸ¬ ê°œ)
                const maneGeo = new THREE.BoxGeometry(1, 4, 2);
                for (let i = 0; i < 5; i++) {
                    const mane = new THREE.Mesh(maneGeo, blackMat);
                    mane.position.set(0, 8 + i * 0.5, -2 - i * 2);
                    mane.rotation.x = -0.5 - i * 0.1;
                    this.headGroup.add(mane);
                }

                this.mesh.add(this.headGroup);

                // === ê¼¬ë¦¬ ===
                const tailGeo = new THREE.CylinderGeometry(0.5, 1.5, 12, 6);
                this.tail = new THREE.Mesh(tailGeo, blackMat);
                this.tail.position.set(0, 16, 14);
                this.tail.rotation.x = 0.8;
                this.tail.castShadow = true;
                this.mesh.add(this.tail);

                // === ë‹¤ë¦¬ (4ê°œ, ê´€ì ˆ ìˆìŒ) ===
                this.legs = [];
                const legPositions = [
                    { x: -4, z: 7 },   // ë’·ë‹¤ë¦¬ ì™¼ìª½
                    { x: 4, z: 7 },    // ë’·ë‹¤ë¦¬ ì˜¤ë¥¸ìª½
                    { x: -4, z: -7 },  // ì•ë‹¤ë¦¬ ì™¼ìª½
                    { x: 4, z: -7 }    // ì•ë‹¤ë¦¬ ì˜¤ë¥¸ìª½
                ];

                legPositions.forEach((pos, i) => {
                    const legGroup = new THREE.Group();
                    legGroup.position.set(pos.x, 10, pos.z);

                    // í—ˆë²…ì§€
                    const thighGeo = new THREE.CylinderGeometry(2, 1.5, 8, 6);
                    const thigh = new THREE.Mesh(thighGeo, this.bodyMat);
                    thigh.position.y = -2;
                    thigh.castShadow = true;
                    legGroup.add(thigh);

                    // ì¢…ì•„ë¦¬
                    const calfGeo = new THREE.CylinderGeometry(1.5, 1, 7, 6);
                    const calf = new THREE.Mesh(calfGeo, this.bodyMat);
                    calf.position.y = -9;
                    calf.castShadow = true;
                    legGroup.add(calf);

                    // ë°œêµ½
                    const hoofGeo = new THREE.CylinderGeometry(1.2, 1.5, 2, 6);
                    const hoof = new THREE.Mesh(hoofGeo, hoofMat);
                    hoof.position.y = -13.5;
                    hoof.castShadow = true;
                    legGroup.add(hoof);

                    this.mesh.add(legGroup);
                    this.legs.push(legGroup);
                });

                // === ì´ë¦„í‘œ (ë¹Œë³´ë“œ) ===
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 256; canvas.height = 64;
                ctx.fillStyle = "rgba(0,0,0,0.8)";
                ctx.beginPath();
                ctx.roundRect(0, 0, 256, 64, 10);
                ctx.fill();
                ctx.strokeStyle = "#fff"; ctx.lineWidth = 3;
                ctx.stroke();
                ctx.fillStyle = "white"; ctx.font = "bold 32px Arial";
                ctx.textAlign = "center"; ctx.fillText(name, 128, 43);
                this.label = new THREE.Sprite(
                    new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true })
                );
                this.label.scale.set(28, 7, 1);
                scene.add(this.label);

                // === ë°°ì¹˜ ===
                const laneWidth = currentTrackWidth / total;
                this.mesh.position.x = (index * laneWidth) - (currentTrackWidth / 2) + (laneWidth / 2);
                this.mesh.position.z = 0;

                scene.add(this.mesh);

                this.baseSpeed = Math.random() * 0.15 + 0.75; // 0.75 ~ 0.9 (ë²”ìœ„ ì¶•ì†Œ)
                this.speed = this.baseSpeed;
                this.finished = false;
                this.status = 'run';
                this.statusTimer = 0;
                this.wobbleOffset = Math.random() * 100;
                this.rank = 0; // í˜„ì¬ ìˆœìœ„
            }

            update() {
                // ì´ë¦„í‘œ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (í•­ìƒ - ê³¨ì¸ í›„ì—ë„)
                this.label.position.set(
                    this.mesh.position.x,
                    this.mesh.position.y + 40,
                    this.mesh.position.z
                );

                if (this.finished) return;

                // ì• ë‹ˆë©”ì´ì…˜
                const time = Date.now() * 0.015 + this.wobbleOffset;
                if (this.status !== 'shock') {
                    // ë‹¤ë¦¬ ì• ë‹ˆë©”ì´ì…˜ (ë’·ë‹¤ë¦¬ì™€ ì•ë‹¤ë¦¬ê°€ êµì°¨)
                    this.legs[0].rotation.x = Math.sin(time) * 0.6;      // ë’·ë‹¤ë¦¬ ì™¼ìª½
                    this.legs[1].rotation.x = Math.sin(time + Math.PI) * 0.6;  // ë’·ë‹¤ë¦¬ ì˜¤ë¥¸ìª½
                    this.legs[2].rotation.x = Math.sin(time + Math.PI) * 0.6;  // ì•ë‹¤ë¦¬ ì™¼ìª½
                    this.legs[3].rotation.x = Math.sin(time) * 0.6;      // ì•ë‹¤ë¦¬ ì˜¤ë¥¸ìª½

                    // ëª¸ ìœ„ì•„ë˜ ì›€ì§ì„
                    this.mesh.position.y = Math.abs(Math.sin(time * 2)) * 2;

                    // ë¨¸ë¦¬ ìœ„ì•„ë˜ í”ë“¤ë¦¼ (ë‹¬ë¦¬ëŠ” ëŠë‚Œ)
                    this.headGroup.rotation.x = Math.sin(time * 2) * 0.15;

                    // ê¼¬ë¦¬ ì¢Œìš° í”ë“¤ë¦¼
                    this.tail.rotation.z = Math.sin(time * 3) * 0.4;
                    this.tail.rotation.x = 0.8 + Math.sin(time * 2) * 0.2;

                    // ê·€ íŒ”ë‘ê±°ë¦¼
                    this.earL.rotation.z = -0.3 + Math.sin(time * 4) * 0.1;
                    this.earR.rotation.z = 0.3 + Math.sin(time * 4 + 1) * 0.1;

                } else { // ë²¼ë½ ë§ì•˜ì„ ë•Œ
                    this.mesh.rotation.x = Math.sin(time * 8) * 0.15; // ë¹ ë¥¸ ê²½ë ¨
                    this.mesh.rotation.z = Math.sin(time * 6) * 0.1;
                    this.mesh.position.y = Math.random() * 3; // íŒŒë‹¥íŒŒë‹¥
                }

                // ìƒíƒœì´ìƒ í•´ì œ
                if (this.statusTimer > 0) {
                    this.statusTimer--;
                    if (this.statusTimer <= 0) this.resetStatus();
                }

                // ëŸ¬ë²„ë°´ë”© (ìˆœìœ„ì— ë”°ë¥¸ ì†ë„ ì¡°ì ˆ)
                // ë’¤ì²˜ì§ˆìˆ˜ë¡ ë¹¨ë¼ì§€ê³ , ì•ì„œê°ˆìˆ˜ë¡ ëŠë ¤ì§
                const totalHorses = horses.filter(h => !h.finished).length;
                if (totalHorses > 1 && this.rank > 0) {
                    const rankRatio = (this.rank - 1) / (totalHorses - 1); // 0(1ë“±) ~ 1(ê¼´ë“±)
                    // ê¼´ë“±ì€ +30% ë³´ë„ˆìŠ¤, 1ë“±ì€ -10% íŒ¨ë„í‹°
                    const rubberBand = 0.9 + rankRatio * 0.4;
                    this.speed = this.baseSpeed * rubberBand;
                }

                // ëœë¤ ì†ë„ ë³€ë™ (ê°€ë”ì”©)
                if (Math.random() < 0.02) {
                    this.speed = this.baseSpeed * (0.8 + Math.random() * 0.5);
                }

                // ì´ë™
                let currentSpeed = this.speed;
                if (this.status === 'boost') currentSpeed *= 2.5;
                if (this.status === 'stun' || this.status === 'shock') currentSpeed = 0;
                if (this.status === 'back') currentSpeed = -0.8;

                this.mesh.position.z -= currentSpeed;

                // ëœë¤ ìŠ¤í‚¬
                if (this.status === 'run' && Math.random() < 0.0015) {
                    this.triggerRandomSkill();
                }

                if (this.mesh.position.z <= finishLineZ) {
                    this.finished = true;
                    finishedCount++;
                    addLog(`ğŸ ${this.name} ê³¨ì¸!!!`);
                    addToRank(this.name);

                    // 1ë“±ì´ë©´ í­ì£½!
                    if (finishedCount === 1) {
                        celebrateWinner(this.mesh.position.clone());
                        addLog(`ğŸ‰ğŸ‰ğŸ‰ ${this.name} ìš°ìŠ¹!!! ğŸ‰ğŸ‰ğŸ‰`);
                    }

                    // 2ëª… ê³¨ì¸í•˜ë©´ ê²½ê¸° ì¢…ë£Œ
                    if (finishedCount >= 2) {
                        isRacing = false;
                        setTimeout(() => {
                            addLog("ğŸ† ê²½ê¸° ì¢…ë£Œ! 1, 2ë“±ì´ ê²°ì •ë˜ì—ˆìŠµë‹ˆë‹¤!");
                            document.getElementById('rank-board').style.display = 'block';
                        }, 1500);
                    }
                }
            }

            applyPenalty() {
                this.status = 'shock';
                this.statusTimer = 300; // 5ì´ˆ ë™ì•ˆ ê¸°ì ˆ
                this.bodyMat.color.setHex(0x000000); // ì™„ì „ ê²€ì •ìœ¼ë¡œ íƒ€ë²„ë¦° ìƒ‰
                this.headMat.color.setHex(0x333333); // ë¨¸ë¦¬ë„ ì–´ë‘¡ê²Œ

                const flash = document.getElementById('flash-overlay');
                flash.style.opacity = 1;
                setTimeout(() => flash.style.opacity = 0, 100);
                
                playThunder();
                addLog(`âš¡ ì¾…!!! ${this.name} ì„ ìˆ˜, ë…ì£¼í•˜ë‹¤ ë²¼ë½ ë§ì•˜ìŠµë‹ˆë‹¤!!`);
            }

            triggerRandomSkill() {
                const r = Math.random();
                if (r < 0.3) {
                    this.status = 'boost'; this.statusTimer = 100;
                    addLog(`ğŸš€ ${this.name}: ìŠ¤í¼íŠ¸ ì˜¬ë¦½ë‹ˆë‹¤!`);
                } else if (r < 0.5) {
                    this.status = 'stun'; this.statusTimer = 100;
                    addLog(`ğŸ’¤ ${this.name}: ì ì‹œ ë”´ì²­ í”¼ì›ë‹ˆë‹¤.`);
                } else if (r < 0.7) {
                    this.status = 'back'; this.statusTimer = 80;
                    addLog(`ğŸ”™ ${this.name}: ë’¤ë¡œ ê°‘ë‹ˆë‹¤?!`);
                } 
            }

            resetStatus() {
                this.status = 'run';
                this.bodyMat.color.setHex(this.originalColor); // ìƒ‰ìƒ ë³µêµ¬
                this.headMat.color.setHex(this.originalColor); // ë¨¸ë¦¬ ìƒ‰ìƒë„ ë³µêµ¬
                this.mesh.rotation.set(0, 0, 0);
            }
        }

        // --- ì‹œìŠ¤í…œ ì—…ë°ì´íŠ¸ ---
        function updateSystem() {
            if (!isRacing || horses.length === 0) return;

            // ìˆœìœ„ ê³„ì‚° (ê³¨ì¸í•˜ì§€ ì•Šì€ ë§ë“¤ë§Œ)
            let sorted = [...horses].filter(h => !h.finished).sort((a, b) => a.mesh.position.z - b.mesh.position.z);

            // ê° ë§ì˜ ìˆœìœ„ ì—…ë°ì´íŠ¸
            sorted.forEach((horse, index) => {
                horse.rank = index + 1;
            });

            let leader = sorted[0];
            let second = sorted[1];

            if (!leader) return; // ëª¨ë‘ ê³¨ì¸í•œ ê²½ìš°

            let dist = Math.floor(Math.abs(finishLineZ - leader.mesh.position.z));
            if (leader.mesh.position.z <= finishLineZ) dist = 0;
            document.getElementById('distLabel').innerText = `ì„ ë‘ ë‚¨ì€ ê±°ë¦¬: ${dist}m`;

            if (second && !leader.finished) {
                let gap = Math.abs(second.mesh.position.z - leader.mesh.position.z);
                document.getElementById('gapLabel').innerText = `2ë“±ê³¼ì˜ ê²©ì°¨: ${Math.floor(gap)}m`;

                document.getElementById('gapLabel').style.color = gap > 300 ? '#ff4757' : 'white';

                if (gap > PENALTY_THRESHOLD && leader.status === 'run') {
                    leader.applyPenalty();
                }
            }

            dirLight.position.z = leader.mesh.position.z + 100;
            dirLight.target.position.z = leader.mesh.position.z;
            dirLight.target.updateMatrixWorld();

            const targetPos = leader.mesh.position.clone();

            // 500m ì´ë‚´ë©´ ê²°ìŠ¹ì„  ì‚¬ì´ë“œ ë·°ë¡œ ê³ ì •
            if (dist <= 500 && dist > 0) {
                // ì˜¤ë¥¸ìª½ì—ì„œ ê²°ìŠ¹ì„  ì „ì²´ë¥¼ ë°”ë¼ë³´ëŠ” ë·°
                const desiredPos = new THREE.Vector3(400, 80, finishLineZ + 50);
                camera.position.lerp(desiredPos, 0.03);
                camera.lookAt(new THREE.Vector3(0, 20, finishLineZ));
                return;
            }

            // ì¹´ë©”ë¼ ëª¨ë“œ ìˆœì„œ (ì „ì²´ ë·° ë¹„ì¤‘ ë†’ì„)
            // 0: ì „ì²´ ë’¤ë”°ë¼ê°€ê¸°, 1: ì „ì²´ íƒ‘ë·°, 2: ì „ì²´ ì‚¬ì´ë“œ, 3: ì„ ë‘ íŠ¸ë˜í‚¹, 4: ì „ì²´ íƒ‘ë·°, 5: ì „ì²´ ì‚¬ì´ë“œ
            if (frameCount % 350 === 0) cameraMode = (cameraMode + 1) % 6;

            let desiredPos;
            if (leader.status === 'shock') {
                // ë²¼ë½ ë§ìœ¼ë©´ ê°€ê¹Œì´ì„œ ë³´ì—¬ì£¼ê¸°
                desiredPos = new THREE.Vector3(targetPos.x + 30, 20, targetPos.z + 40);
                camera.lookAt(targetPos);
            } else {
                if (cameraMode === 0) { // ì „ì²´ ë’¤ë”°ë¼ê°€ê¸° (ëª¨ë“  ë§ì´ ë³´ì´ëŠ” ë’¤ìª½ ë·°)
                    desiredPos = new THREE.Vector3(0, 60, targetPos.z + 150);
                    camera.lookAt(new THREE.Vector3(0, 10, targetPos.z - 50));
                } else if (cameraMode === 1 || cameraMode === 4) { // ì „ì²´ íƒ‘ë·°
                    desiredPos = new THREE.Vector3(0, 300, targetPos.z + 100);
                    camera.lookAt(new THREE.Vector3(0, 0, targetPos.z));
                } else if (cameraMode === 2 || cameraMode === 5) { // ì „ì²´ ì‚¬ì´ë“œë·°
                    desiredPos = new THREE.Vector3(currentTrackWidth + 100, 60, targetPos.z);
                    camera.lookAt(new THREE.Vector3(0, 10, targetPos.z));
                } else if (cameraMode === 3) { // ì„ ë‘ íŠ¸ë˜í‚¹ (ê°€ë” ê°œì¸ë·°)
                    desiredPos = new THREE.Vector3(targetPos.x + 40, 30, targetPos.z + 60);
                    camera.lookAt(targetPos);
                }
            }
            camera.position.lerp(desiredPos, 0.04);
        }

        function addLog(msg) {
            const el = document.getElementById('broadcast-text');
            el.innerText = msg;
            el.style.transform = "scale(1.1)";
            setTimeout(() => el.style.transform = "scale(1)", 150);
        }

        function addToRank(name) {
            const list = document.getElementById('rank-list');
            const li = document.createElement('li');
            li.innerText = `${finishedCount}ìœ„ : ${name}`;
            if(finishedCount === 1) li.classList.add('winner');
            list.appendChild(li);
        }

        function animate() {
            requestAnimationFrame(animate);
            frameCount++;

            // êµ¬ë¦„ í•­ìƒ ì›€ì§ì„
            updateClouds();

            // í­ì£½ í•­ìƒ ì—…ë°ì´íŠ¸
            updateFireworks();

            if (isRacing) {
                horses.forEach(h => h.update());
                updateSystem();
            }
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- ì¹´ìš´íŠ¸ë‹¤ìš´ ---
        function startCountdown(callback) {
            const countdownEl = document.getElementById('countdown');
            const counts = ['3', '2', '1', 'GO!'];
            let index = 0;

            countdownEl.style.display = 'block';

            function showNext() {
                if (index < counts.length) {
                    countdownEl.textContent = counts[index];
                    countdownEl.style.animation = 'none';
                    countdownEl.offsetHeight; // reflow
                    countdownEl.style.animation = 'countPulse 0.5s ease-out';

                    // ì¹´ìš´íŠ¸ ì†Œë¦¬
                    if (index < 3) {
                        playTone(400, 'square', 0.2, 0.3);
                    } else {
                        playTone(800, 'square', 0.4, 0.4);
                    }

                    index++;
                    setTimeout(showNext, 800);
                } else {
                    countdownEl.style.display = 'none';
                    callback();
                }
            }

            showNext();
        }

        document.getElementById('startBtn').addEventListener('click', () => {
            const input = document.getElementById('names').value;
            let names = input.split('\n').map(n => n.trim()).filter(n => n);

            if (names.length < 2) { alert('ìµœì†Œ 2ëª… í•„ìš”'); return; }
            if (names.length > MAX_LANES) {
                alert(`ìµœëŒ€ ${MAX_LANES}ëª…ê¹Œì§€ ì°¸ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤. ì²˜ìŒ ${MAX_LANES}ëª…ë§Œ ì°¸ê°€í•©ë‹ˆë‹¤.`);
                names = names.slice(0, MAX_LANES);
            }

            document.getElementById('setup-box').style.display = 'none';

            // ë§ ìˆ˜ì— ë§ê²Œ íŠ¸ë™ ë‹¤ì‹œ ìƒì„±
            createTrack(names.length);
            createFinishLine();

            // ë§ë“¤ ìƒì„±
            names.forEach((name, i) => horses.push(new Horse3D(name, i, names.length)));

            // ì¹´ìš´íŠ¸ë‹¤ìš´ í›„ ì‹œì‘
            startCountdown(() => {
                document.getElementById('broadcast').style.display = 'block';
                isRacing = true;
                addLog(`ğŸ“¢ ${names.length}ëª… ì¶œë°œ! ë…ì£¼í•˜ë©´ ìœ„í—˜í•©ë‹ˆë‹¤!`);
            });
        });

        init();
    </script>
</body>
</html>